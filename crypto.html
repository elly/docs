<html>
 <head>
  <link rel="stylesheet" type="text/css" href="mono.css" />
 </head>
 <body>
<p>
This page is a basic primer on the <a href="#glossary">terminology</a> and <a
href="#principles">principles</a> of cryptography.  The target audience is
people familiar with the basics of computer science or mathematics.
</p>

<p><a name="principles" />
Cryptography is a school of study primarily concerned with two goals:
<b>confidentiality</b> and <b>authenticity</b>. Confidentiality of a message
means that nobody other than the intended recipient(s) can read the message;
authenticity of a message means that the recipient(s) can be confident that the
message comes from a particular source and has not been tampered with or
altered. An important notion is the idea of <b>proof</b> - of demonstrating to a
recipient that something is true beyond reasonable doubt in a way that the
recipient can easily verify. A <b>message</b> is a sequence of symbols; symbols
in this context will usually be bytes, although they may also be letters or
individual bits.
</p>

<p>
First, let's introduce our cast of characters. <b>Alice</b>, <b>Bob</b>,
<b>Charlie</b> and <b>Dave</b> are users of cryptographic protocols; they are
trying to send messages to one another or prove things to each other. <b>Eve</b>
is a malicious eavesdropper; she can listen to messages as they pass between
users of protocols, but cannot modify them. <b>Mallory</b> is a
<b>man-in-the-middle</b>; Mallory can not only listen to messages passing
between users, but also modify them. Sometimes, <b>Trent</b> will make an
appearance; Trent is a third party that all users of a protocol trust
implicitly. Trent might be a bank or a government in some examples.
</p>

<p>
Now let's talk (abstractly) about the classes of primitives cryptography deals
in. Broadly speaking, we can divide cryptographic primitives into three classes:
<b><a href="#hash">hash functions</a></b>, <b><a href="#symm">symmetric
ciphers</a></b>, and <b><a href="#asymm">asymmetric ciphers</a></b>. A
<b>cipher</b> is a pair of functions, called an <b>encryption function</b> and a
<b>decryption function</b>; the encryption function accepts a <b>plaintext</b>
(unencrypted message) and a <b>key</b>, and produces a <b>ciphertext</b>
(encrypted message), and the decryption function accepts a ciphertext and a key
(not necessarily the same as was provided to the encryption function) and
produces the original plaintext.
</p>

<p><b><a name="hash" href="#hash">Hash Functions</a></b></p>
<p>
A <b>hash function</b> turns a message of any length into a string of fixed
length, called a <b>hash</b>, <b>digest</b>, or <b>fingerprint</b>. A hash
function is a function in the mathematical sense, meaning that its output is
entirely determined by its input, so the same message will always have the same
hash. A simple example of a <b>non-cryptographic</b> hash function of a sequence
S_0, S_1, ... S_n of bytes might be:
</p>

<p><pre>
  simple(n) = (S_0 + S_1 + ... + S_n) mod 256
</pre></p>

<p>
This example hash function takes a message of any length and produces a string
of fixed length; in this case, the hash is 8 bits long. We can see how we could
use this function to detect <b>accidental</b> errors when transmitting a
message: if we computed the hash <tt>simple(m)</tt> of a message <tt>m</tt> we
wished to send and sent that as well, if <tt>m</tt> were accidentally corrupted,
we would be quite likely to notice, since the recipient would be able to compute
<tt>simple</tt> of the corrupted <tt>m</tt> and see that it did not match our
<tt>simple(m)</tt>. However, if Mallory were modifying <tt>m</tt>, she could
also quite simply modify <tt>m</tt> to produce <tt>m'</tt> (pronounced "m
prime") in such a way that <tt>simple(m')</tt> was equal to <tt>simple(m)</tt>.
The fact that this is easy to do for Mallory is part of what makes
<tt>simple</tt> a non-cryptographic hash.
</p>

<p>
A <b>cryptographic hash</b> has to be resistant to such attempts at
manipulation. In fact, a cryptographic hash function <tt>H</tt> should have
these four properties:
<ul>
 <li>Given <tt>m</tt>, it is easy to compute <tt>H(m)</tt>. There is no common
     name for this property, but we'll call it <b>image easiness</b>.</li>
 <li>Given a hash value <tt>h</tt>, it is difficult to compute any <tt>m</tt>
     such that <tt>H(m)</tt> is equal to <tt>h</tt>. This property is called
     <b>preimage resistance</b>.</li>
 <li>Given <tt>m</tt>, it is difficult to compute <tt>m'</tt> such that
     <tt>H(m)</tt> and <tt>H(m')</tt> are equal. This property is called
     <b>second preimage resistance</b>.</li>
 <li>It is difficult to find <tt>m</tt> and <tt>m'</tt> such that <tt>H(m)</tt>
     and <tt>H(m')</tt> are equal. This property is called <b>collision
     resistance</b>.</li>
</ul>
</p>

<p>
We can evaluate <tt>simple</tt> by these criteria:
<ul>
 <li><b>Image easiness</b>: Yes. The algorithm given for <tt>simple</tt> is
     trivial to implement.</li>
 <li><b>Preimage resistance</b>: No. Given any 8-bit value <tt>h</tt>, we can easily find
     as many messages <tt>m</tt> as we like for which <tt>simple(m) = h</tt>.
     For example, <tt>simple(h) = h</tt>, and <tt>simple({h, 0}) = h</tt>, as
     does <tt>simple({h, 0, 0...})</tt>.</li>
 <li><b>Second preimage resistance</b>: No, for the same reason as <tt>h</tt>
     does not have preimage resistance.</li>
 <li><b>Collision resistance</b>: No. For example, <tt>simple({15, 5}) =
     simple({10, 10})</tt>.</li>
</ul>
</p>

<p>
There's something you might have noticed above: although it is easy, given some
<tt>h</tt>, to find some <tt>m</tt> such that <tt>simple(m) = h</tt>, if I give
you <tt>h = simple(m)</tt>, you have no way of finding the <i>specific</i> <tt>m</tt>
that I used to compute <tt>h</tt>. It's easy to see why this is: <tt>m</tt> could
have been a single byte equal to <tt>h</tt>, or two bytes that sum to <tt>h</tt>, or three bytes
that sum to <tt>h</tt>, and so on. <tt>simple</tt> actually has the following
alarming property: for each one-byte value <tt>h</tt>, there are
<i>infinitely</i> many values <tt>m_0, m_1, ...</tt> such that <tt>simple(m_i) =
h</tt>.
</p>

<p>
The details of how to construct functions with those four desired properties are
highly technical (and, in fact, over the author's head, mathematically), so
we'll restrict ourselves to looking at the current field of hash functions in
wide use:
<ul>
 <li><b>MD5</b>: MD5 has been publicly broken and should not be used. In 2005,
     MD5's second-preimage resistance was broken. It produces a 128-bit hash
     value.</li>
 <li><b>SHA-1</b>: SHA-1 was designed by the NSA and is similar to MD5
     design-wise; it has not yet been broken but is showing weaknesses and is <a
     href="csrc.nist.gov/groups/ST/toolkit/documents/shs/hash_standards_comments.pdf">deprecated
     by NIST</a>. It produces a 160-bit hash value.</li>
 <li><b>SHA-2</b>: a generic name for a family of secure hash functions designed
     by the NSA to replace SHA-1. Specific functions in this family are
     <b>SHA-224</b>, <b>SHA-256</b>, <b>SHA-384</b>, and <b>SHA-512</b>. These
     functions have not (as of 2012) been successfully attacked, but an effort
     is under way to produce a standardized replacement. These functions are
     named after their output lengths in bits.</li>
</ul>
</p>

<p>
Now let's look at some applications of hash functions. Let's suppose that Alice
is talking to Bob over a <b>secure channel</b> (that is to say, Alice and Bob's
messages to each other are authenticated and confidential). Alice has downloaded
a large file from a particular website (a Linux install image, for example) and
found it satisfactory, and is recommending the same website to Bob to download
the same image. Bob can download the file from that site as well, but Bob has no
easy way to tell that he got the same file that Alice did without sending the
entire file over the secure channel so one of the parties can compare them.
Enter the hash function! Instead of sending the entire file to Bob so he can
compare, Alice can compute a hash of the copy she has, then send the hash to Bob
over their secure channel; Bob can compute the hash of the copy he has and check
that the two hashes are equivalent. If the two hashes are equivalent, Bob can be
extremely confident that he has the same file. This is an application of
<b>second preimage resistance</b> of the hash function Alice and Bob are using;
given the satisfactory copy Alice has (<tt>m</tt>), it would be very difficult
for either the mirror or Mallory (who could be corrupting Bob's download) to
find a corrupted copy <tt>m'</tt> such that <tt>h(m) = h(m')</tt>.
</p>

<p>
Another application of hash functions it to produce a <b>proof of foreknowledge</b>.
Let's suppose that Alice has insider knowledge of an event that will happen in
the future, and wants to be able to prove to Bob that she knew about that event
in advance when it happens without telling Bob anything about the event in
advance. Alice can write a message <tt>m</tt> describing the event, then give
Bob <tt>h(m)</tt>; when the event happens, Alice can reveal <tt>m</tt> to Bob,
and Bob can be confident that Alice had produced <tt>m</tt> when she originally
gave him <tt>h(m)</tt>, as a result of the preimage resistance of <tt>h</tt>.
</p>

<p><b><a name="symm" href="#symm">Symmetric Ciphers</a></b></p>
<p>
So far we've seen hash functions and their applications for authenticity and
proofs, but we haven't yet seen a way to get confidentiality. Enter <b>symmetric
ciphers</b>. A cipher is a pair of functions <b><tt>E(k,m)</tt></b> (which
encrypts a plaintext message <tt>m</tt> with a key <tt>k</tt> to produce a
ciphertext, often called <tt>c</tt> in examples) and <b><tt>D(k,c)</tt></b>
(which decrypts a ciphertext message <tt>c</tt> with a key <tt>k</tt> to produce
a plaintext message <tt>m</tt>). A cipher is <b>symmetric</b> if the same key
<tt>k</tt> is used for both encryption and decryption. A symmetric cipher has
the property that <b><tt>D(k,E(k,m)) = m</tt></b>.
</p>

<p>
A simple (and historic) example of a symmetric cipher is the <b>Caesar
cipher</b>. The Caesar cipher operates on a stream of bytes and uses a one-byte
key, and has the following E and D functions:
</p>

<p><pre>
  E(k,m) = { m_i + k for m_i in m }
  D(k,c) = { c_i - k for c_i in c }
</pre></p>

<p>
That is to say: to encrypt, add k to each byte in the message, mod 256; to
decrypt, subtract k from each byte in the message, mod 256. It's easy to see how
we might go about recovering <tt>m</tt> given <tt>E(...,m)</tt>: we can just try
all 256 possible values of k and see which value of <tt>D(k,E(...,m))</tt> looks
sensible. This attack is known as <b>brute force</b> - the process of attacking
a cryptographic algorithm by trying all the possible values for some secret
value. It is important to note that <b>all</b> cryptographic systems are
<i>eventually</i> breakable by brute force (with some <a href="#otp">notable
exceptions</a>), but for cryptographic systems used in practice, brute force
often requires too much work to be a feasible attack.
</p>

<p><a name="otp" />
Let's discuss another historic symmetric cipher: the <b>one-time pad</b>. In
order to use a one-time pad on a message <tt>m</tt>, we need a key <tt>k</tt> of
the same length as the message <tt>m</tt>; the encryption and decryption
functions are then:
</p>

<p><pre>
  E(k,m) = { m_i ^ k_i for m_i in m }
  D(k,c) = { c_i ^ k_i for c_i in c }
</pre></p>

<p>
You'll notice that E and D have the same definition: this is a consequence of
the <tt>^</tt> (xor) operator, which has the property that <tt>x ^ y ^ y =
x<tt>. Encryption using one-time pads is <i>unbreakable</i> under certain (very
strict) assumptions about use of the cipher:
</p>
<p><ul>
 <li>The key must be truly random, so that it is impossible for the attacker to
     predict any bit of the key.</li>
 <li>No byte of the key may ever be reused, either for this message or any
     other</li>
 <li>The key must be kept secret</li>
</ul></p>

<p>
Under these assumptions, one-time pads have the <b>perfect secrecy</b> property;
the ciphertext contains no information about the plaintext. A practical result
of this is that brute force is impossible: by changing which key is chosen,
<i>any</i> plaintext can be decrypted from a given ciphertext, so brute force is
impossible; we have no way of detecting the correct message unless we know it in
advance. More concretely, suppose an attacker tries to decrypt <tt>E(k,m)</tt>
with some other key <tt>k'</tt>:
</p>

<p><pre>
  m = "hello"  = { 0x68, 0x65, 0x6c, 0x6c, 0x6f }
  k            = { 0xda, 0xf0, 0x88, 0x1a, 0x27 }
  E(k,m)       = { 0xb2, 0x95, 0xe4, 0x76, 0x48 }
  k'           = { 0xdf, 0xfc, 0x97, 0x02, 0x31 }
  m' = "misty" = { 0x6d, 0x69, 0x73, 0x74, 0x79 }
</pre></p>

<p>
Unfortunately, one-time pads are very difficult to use in practice. If Alice
wishes to send a one-time-pad encrypted message to Bob, Alice and Bob must
already have shared a one-time-pad key of sufficiently length to encrypt the
entire message, which must have been generated randomly and kept secret by both
of them. This is not infeasible - for example, Alice could have generated
several gigabytes of random data, placed it on physical storage, and handed it
to Bob in person at some earlier time - but it is difficult to do at scale and
without a preexisting secure way to transfer keys.
</p>

<p>
Both of the previous ciphers are called <b>stream ciphers</b>: they operate on a
stream of data of arbitrary length. Many modern symmetric ciphers are <b>block
ciphers</b> instead, which operate on fixed-size blocks of data. A block cipher
operates on a <b>block</b> of fixed length at a time. A block cipher has an
encryption and decryption function, but instead of accepting arbitrary-length
plaintext and ciphertext, they accept single blocks at a time, and produce
single blocks. An example of a simple (and <i>extremely</i> insecure) block
cipher might be the following function, which accepts a 128-bit key and a
128-bit block:
</p>

<p><pre>
  simple-block-E(k[16],m[16]) = { m_i ^ k_i for m_i in m }
  simple-block-D(k[16],m[16]) = { m_i ^ k_i for m_i in m }
</pre></p>

<p>
Note that this cipher is essentially a constrained version of the one-time-pad
cipher given above. An additional question with a block cipher is how to encrypt
messages of more than one block, which introduces the concept of a <b>mode</b>
of a block cipher. When discussing these ciphers, we'll break the message
<tt>m</tt> into a sequence of blocks <tt>m_0, m_1, ..., m_n</tt> (and the
ciphertext <tt>c</tt> into a sequence of blocks <tt>c_0, c_1, ..., c_n</tt>).
The simplest mode is called <b>ECB</b>, which is short for <b>electronic code
book</b>; in this mode, plaintext is encrypted by encrypting successive blocks
of it with the cipher's encryption function, and ciphertext is decrypted by
decrypting successive blocks with the cipher's decryption function.  ECB looks
like this:
</p>

<p><pre>
  simple-ecb-E(k[16],m_i) = simple-block-E(k,m_i)
  simple-ecb-D(k[16],c_i) = simple-block-D(k,c_i)
</pre></p>

<p>
There's an alarming property inherent in simple-ecb-E: If our plaintext
<tt>m</tt> contains two blocks <tt>m_i</tt> and <tt>m_j</tt> that are
equivalent, then <tt>c_i</tt> and <tt>c_j</tt> will be equivalent - and as a
further consequence, if Mallory knows some <tt>m_i</tt>, she can copy the
corresponding <tt>c_i</tt> over <tt>c_j</tt> to replace <tt>m_j</tt> with
<tt>m_i</tt>!. This discovery motivates the second block cipher mode, which is
called <b>CBC</b> (short for <b>cipher block chaining</b>). In CBC, a dependency
exists between each block of ciphertext and all of those before it. CBC looks
like this:
</p>

<p><pre>
  simple-cbc-E(k[16],m_i) = simple-block-E(k,m_i ^ c_{i - 1})
  simple-cbc-D(k[16],c_i) = simple-block-D(k,c_i) ^ c_{i - 1}
</pre></p>

<p>
You'll notice that as this mode is given right now, there is no way to encrypt
c_0, since there's no c_{-1}. Therefore, we introduce a fake block at c_{-1},
which we call the <b>initialization vector</b>, or <b>IV</b> for short. This
fake block is prepended to the message before it is sent, where the sender can
decrypt it and use it for CBC. CBC is widely used, but has some disadvantages:
</p>

<p><ul>
 <li>Since each block depends on the block before it, encryption cannot be
     parallelized.</li>
 <li>Since each block depends on the block before it, it is not possible to
     change part of a large message encrypted with a block cipher in the CBC
     mode without re-encrypting all the subsequent parts of the plaintext.</li>
</ul></p>

<p>
There are a great many other block cipher modes, which are too numerous to list
or discuss here, but it is worth calling out one more, which is called
<b>CTR</b> (short for <b>counter</b>) mode. CTR mode turns a block cipher into a
stream cipher by using the block cipher to generate a stream of bytes to xor
with the plaintext. To use CTR mode, one chooses a <b>nonce</b> (short for
"number used once") and a <b>counter</b>. We can then generate a key stream by
encrypting successive values of the nonce combined with the counter. Let the
generated key <tt>k'</tt> have length equal to the length of <tt>m</tt>, and let
<tt>k'</tt> be composed of blocks <tt>k'_0, k'_1, ..., k'_n</tt>. Then:
</p><pre>
  k'_i = simple-block-E(k,nonce + i)
</pre><p>

<p>
We can now xor <tt>k'</tt> with <tt>m</tt> to produce <tt>c</tt>, and send
<tt>c</tt> and <tt>nonce</tt> to the recipient; the recipient can then
reconstruct <tt>k'</tt> using the same process and compute <tt>c ^ k' = m</tt>.
Note that for CTR mode to be secure, the underlying block cipher used must make
<b>key recovery</b> difficult. Key recovery is the ability to derive <tt>k</tt>
given <tt>m</tt> and <tt>E(k,m)</tt>. The example block cipher we've been using
here does not have this property, since <tt>k = m ^ E(k,m)</tt>.
</p>

<p>
Since <tt>simple</tt> does not have this property, if Alice encrypts any block
of plaintext known to Eve, Eve learns both <tt>c_i</tt> and <tt>m_i</tt>, which
allows her to derive <tt>simple-block-E(k,nonce + i) = c_i ^ m_i</tt>, and since
the Eve knows both the <tt>nonce</tt> and <tt>i</tt>, they can compute
<tt>k</tt>. This is what is called a <b>known-plaintext attack</b> - where
knowing part of the plaintext allows Eve to recover the rest. There are a few
such kinds of attacks:
</p>

<p><ul>
 <li>In a <b>ciphertext-only</b> attack, Eve is assumed to have access only to
     ciphertexts sent between Alice and Bob.</li>
 <li>In a <b>known-plaintext</b> attack, Eve is assumed to have access to some
     plaintexts and their corresponding ciphertexts sent between Alice and Bob,
     and to be attempting to decrypt other ciphertexts sent between them using
     the same key. As explained above, the <tt>simple</tt> block cipher is
     vulnerable to this attack.</li>
 <li>In a <b>chosen-plaintext</b> attack, Eve is assumed to be able to cause
     Alice or Bob to encrypt plaintext of her choosing with their key. The
     <tt>simple</tt> block cipher is also extremely vulnerable to this attack -
     in the extreme case, if Eve can cause Alice or Bob to encrypt a block of
     all zero bytes, the resulting ciphertext will be equal to their key.</li>
 <li>Similarly, in a <b>chosen-ciphertext</b> attack, Eve is assumed to be able
     to cause Alice or Bob to decrypt ciphertext of her choosing with their key.
     The <tt>simple</tt> block cipher is similarly vulnerable to this attack -
     if Eve can cause Alice or Bob to decrypt a ciphertext block composed of
     all zero bytes, the resulting plaintext will be equal to their key.</li>
 <li>In an <b>adaptive</b> attack, Eve is assumed to be able to supply
     additional chosen plaintexts or ciphertexts after viewing previous ones, so
     she can adapt her attack to things she has learned earlier.</li>
</ul></p>

<p>
Unfortunately, as with hash functions, existing block ciphers are too
complicated to describe concisely, and attempting to do so would betray an
embarassing lack of mathematical sophistication on the author's part, so it will
have to suffice to list some that are in common use:
</p>

<p><ul>
 <li><b>DES</b>, short for Data Encryption Standard, is an obsolete cipher
     originally designed by IBM with help from the NSA and published in 1977.
     DES uses a 56-bit key to operate on 64-bit blocks, and is notoriously
     irritating to implement in software. In spite of its advanced age and the
     extreme academic scrutiny visited upon it, no feasible attacks better than
     brute force are known. Unfortunately, DES' key length is inadequate, and
     modern machines can successfully break DES keys in less than 24 hours for a
     relatively modest amount of money. DES is obsolete and should not be used
     for new protocols.</li>
 <li><b>3-DES</b>, or Triple-DES, is a block cipher using either 168-bit or
     112-bit key and applying DES multiple times. There are no known feasible
     attacks on Triple-DES, but it is also obsolete and should not be
     used.</li>
 <li><b>AES</b> (formerly known as <b>Rijndael</b>, short for Advanced
     Encryption Standard) is a block cipher operating on a 128-bit block with a
     128, 192, or 256-bit key. There are no feasible attacks on AES, and it is
     the most widely-used symmetric cipher for new protocols.</li>
 <li><b>Blowfish</b>, designed by cryptographer Bruce Schneier, operates on a
     64-bit block and has a variable key length of up to 448 bits. There are no
     known feasible attacks on Blowfish, but it is less popular than AES.</li>
</ul></p>

<p>
Applications of symmetric ciphers are easy to find: they are quite fast
(hundreds of megabytes per second or more on modern hardware) and there are no
known attacks on the best ciphers with appropriately-chosen keys.
</p>

<p><b><a name="hmac" href="#hmac">HMAC</a></b></p>
<p>
It's worth taking a brief detour into a spiritual child of hash functions and
symmetric ciphers: the <b>HMAC</b>, or <b>hashed message authentication
code</b>. Earlier, we saw that hashes let Alice and Bob prove that messages had
not been tampered with, but didn't allow them to authenticate messages between
them; for example, if Alice runs a web server somewhere that has a file
available for download and lists its hash, if Mallory compromises the server,
she can upload her own version of the file and its corresponding hash. An HMAC
is a way of using a hash function such that a hash can only be produced by
someone who knows a particular secret key - so if Alice and Bob share a secret
key, and Alice puts the HMAC of her file up instead of the hash of it, then Bob
can verify the HMAC, and Mallory cannot generate a new valid HMAC as she lacks
the secret key. HMAC is the name both of a class of constructions which turn
hash functions into secret-key authentication functions and the name of a
specific such construction, which I'll describe below.
</p>

<p>
Let's try designing the simplest HMAC construction we can think of. Remembering
from earlier that a good hash function has <b>preimage resistance</b> and
<b>second preimage resistance</b>, we might try doing this (here, "||" is read
as "concatenated with"):
</p>

<p><pre>
  simple-hmac(h,k,m) = h(k || m)
</pre></p>

<p>
Since <tt>h</tt> has preimage resistance, it should be hard for Mallory to
derive <tt>k</tt> given <tt>h(k || m)</tt>, and since <tt>h</tt> has
second-preimage resistance, it should be hard for Mallory to derive <tt>h(k ||
m')</tt> given <tt>h(k || m)</tt>. Unfortunately, as the astute reader will have
guessed from the name of the function, there's a problem. In order to explain,
we'll have to delve a bit into the way modern hash functions are constructed.
</p>

<p>
Modern hash functions are often built with a construction called the
<b>Merkle-Damg&aring;rd construction</b>. The Merkle-Damg&aring;rd construction is
spiritually similar to a block cipher mode - it turns a function called a
<b>compression function</b>, which turns two fixed-length inputs into one
fixed-length output, into a hash function, which turns one variable-length input
into one fixed-length output. Merkle-Damg&aring;rd works as follows, given a
compression function <tt>C</tt> and an IV <tt>I</tt>:
</p>

<p><ol>
 <li>Let <tt>m' = m || len(m) || padding</tt>, where <tt>len</tt> returns a
     fixed-width integer and <tt>padding</tt> is sufficient to make m' an
     integral number of blocks. Call these blocks m'_0, m'_1, ... m'_n.</li>
 <li>Let m'_{-1} = I</li>
 <li>Let s_i = C(m_i, s_i)</li>
 <li>Return s_n</li>
</ol></p>

<p>
Merkle-Damg&aring;rd is popular, but it has one property which concerns us here: if h
is a hash function using the Merkle-Damg&aring;rd construction, then given
<tt>simple-hmac(h,k,m)</tt>, it is easy for Mallory to find
<tt>simple-hmac(h,k,m || len(m) || padding || anything)</tt>. The reason for this is
as follows: suppose Mallory knows <tt>simple-hmac(h,k,m)</tt>. She then really
knows <tt>s_n</tt>, where <tt>s_n</tt> is the state of <tt>h</tt> after applying
<tt>C</tt> to all of the blocks of <tt>m'</tt>. She can exploit this to
undertake a <b>length-extension attack</b>: if she appends a new block m_{n + 1}
to m', then re-appends the new length and padding after m_{n + 1}, she can
easily compute <tt>s_{n + 1} = C(m_{n + 1}, s_n)</tt>. Therefore, the
<tt>simple-hmac</tt> construction is not adequate - Mallory can append whatever
she wants to authentic messages to produce new authentic messages.
</p>

<p>
Enter the HMAC construction. The HMAC construction is as follows, with
<tt>opad</tt> being the byte <tt>0x5c</tt> repeated enough times to form one
block for the hash function, and <tt>ipad</tt> being the byte <tt>0x36</tt>
being repeated enough times to form one block for the hash function:
</p>

<p><pre>
  hmac(h,k,m) = h((k ^ opad) || h((k ^ ipad) || m))
</pre></p>

<p>
The outer invocation of h protects the output state of the inner invocation of
h, which makes length-extension attacks impossible, and since h((k ^ ipad) || m)
has a fixed length, Mallory cannot use her knowledge of the final state of the
outer invocation of h for a length-extension attack either. Instances of
<tt>hmac</tt> with a specific hash value for <tt>h</tt> are often named as
<tt>HMAC-&lt;name&gt;</tt> - e.g., <b>HMAC-SHA256</b>, <b>HMAC-MD5</b>, and so
on.
</p>

<p>
Applications of HMAC are again simple to find: if Alice and Bob share a key
<tt>k</tt>, then Alice can send Bob a message <tt>m</tt> and
<tt>HMAC-SHA256(k,m)</tt>; Bob, using <tt>k</tt>, can compute
<tt>HMAC-SHA256(k,m)</tt> and verify that it matches what Alice sent, and
therefore know that Alice sent <tt>m</tt>. Furthermore, Alice and Bob can
actually use HMAC to distinguish messages and random data; if Alice, with a
message <tt>m</tt> and a key <tt>k</tt>, produces <tt>c = E(k,m) ||
HMAC-SHA256(k,E(k,m))</tt> and posts this value publicly, only Bob (possessing
<tt>k</tt>) will be able to distinguish <tt>c</tt> from random data, since
<tt>c</tt> has the property that its last 256 bits are the <tt>HMAC-SHA256</tt>
of the rest of it under the secret key Alice and Bob share.
</p>

 </body>
</html>
